// Дьяченко
Функция ВремяОперацииСтрокой(ВремяМС) Экспорт

    ВремяВСекундах = ВремяМС / 1000;
    Часы = Цел(ВремяВСекундах/3600);
    Минуты = Цел((ВремяВСекундах - Часы * 3600) / 60);
    Секунды = ВремяВСекундах - Часы * 3600 - Минуты * 60;

    //1 час
    Если Часы > 0  Тогда
        ВремяСтрокой = Строка(Часы) + " ч. " + Строка(Минуты) + " мин. " + Строка(Секунды) + " сек."
    //1 минута
    ИначеЕсли Минуты > 0  Тогда
        ВремяСтрокой = Строка(Минуты) + " мин. " + Строка(Секунды) + " сек."
    //1 секунда
    ИначеЕсли Секунды > 1  Тогда
        ВремяСтрокой = Строка(Секунды) + " сек."
    Иначе
        ВремяСтрокой = Строка(ВремяМС) + " мс."
    КонецЕсли;

    Возврат ВремяСтрокой;

КонецФункции

Функция ПреобразоватьСекунды(КолвоСекунд) Экспорт
	Часов = Цел(КолвоСекунд/3600);
	Минут = Цел((КолвоСекунд-Часов*3600)/60);
	Секунд = КолвоСекунд - Часов*3600 - Минут*60;
	СтрокаВремениВыполнения = "" + Часов + ":" + ?(Минут = 0, "00", Формат(Минут, "ЧЦ=2; ЧДЦ=0; ЧВН=")) + ":" + ?(Секунд = 0, "00", Формат(Секунд, "ЧЦ=2; ЧВН="));
	Возврат СтрокаВремениВыполнения;
КонецФункции

Функция УбратьНеправильныеСимволы(Стр) Экспорт 
	
	Рез = СокрЛП(Стр);
	
	КодНеправильногоСимвола = 182;//пока так, потом можно будет через массив
	Для сч = 1 По СтрДлина(Рез) Цикл
		Если КодСимвола(Рез, сч) = КодНеправильногоСимвола Тогда
			Рез = Лев(Рез, сч - 1) + (Сред(Рез, сч + 1, СтрДлина(Рез)));
		КонецЕсли;
	КонецЦикла;	
	
	Возврат Рез;
	
КонецФункции	

Функция ЭтоЧисло(Слово) Экспорт 
	Если ПустаяСтрока(Слово) Тогда                                          Возврат Ложь		КонецЕсли;	
	                	
	Цифры 																	= "1234567890,.-";
	Для НомСимвола = 1 По СтрДлина(Слово) Цикл
		Если Найти(Цифры, Сред(Слово, НомСимвола, 1)) = 0 Тогда            	Возврат Ложь;   	КонецЕсли;
	КонецЦикла;
	
	Возврат Истина
КонецФункции

// Округляет число по заданному порядку. Если задано (=Истина) "ОкруглятьВБольшуюСторону",
// то число 123.37 при порядке округление 0.5 превратиться в 123.50, а число 0.1 
// при порядке округления 5 станет равным 5.
//
// Параметры:
//  Число                    - исходное число
//  ПорядокОкругления        - элемент перечисления Порядки окгугления: 
//                             "шаг" округления (0.01 (арифметическое), 0.01, 0.05, 0.1, 0.5, 1, 5, 10, 50, 100)
//  ОкруглятьВБольшуюСторону - булево, определяет способ округления: если Истина, 
//                             то при порядке округления "5" 0.01 будет округлена до 5, 
//                             Ложь - округление по арифметическим правилам
//
// Возвращаемое значение:
//  Округленное по заданному порядку значение
//
Функция ОкруглитьЦену(Число, ПараметрПорядокОкругления, ОкруглятьВБольшуюСторону) Экспорт

	Перем Результат;

	// Преобразуем порядок округления числа.
	// Если передали пустое значение порядка, то округлим до копеек. 
	Если НЕ ЗначениеЗаполнено(ПараметрПорядокОкругления) Тогда
		ПорядокОкругления = Перечисления.ПорядкиОкругления.Окр0_01; 
	Иначе
		ПорядокОкругления = ПараметрПорядокОкругления;
	КонецЕсли;

	Порядок = Число(Строка(ПорядокОкругления));
		
	// вычислим количество интервалов, входящих в число
	КоличествоИнтервал	= Число / Порядок;
		
	// вычислим целое количество интервалов.
	КоличествоЦелыхИнтервалов = Цел(КоличествоИнтервал);
		
	Если КоличествоИнтервал = КоличествоЦелыхИнтервалов Тогда
		
		// Числа поделились нацело. Округлять не нужно.
		Результат	= Число;
	Иначе
		Если ОкруглятьВБольшуюСторону Тогда
			
			// При порядке округления "0.05" 0.371 должно округлиться до 0.4
			Результат = Порядок * (КоличествоЦелыхИнтервалов + 1);
		Иначе

			// При порядке округления "0.05" 0.371 должно округлиться до 0.35,
			// а 0.376 до 0.4
			Результат = Порядок * Окр(КоличествоИнтервал,0,РежимОкругления.Окр15как20);
		КонецЕсли; 
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ОкруглитьЦену()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Предназначена для получения пустого значения заданного типа:
// примитивного, или ссылочного.
//
// Параметры:
//  ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	ИначеЕсли ЗаданныйТип = ТипЗнч(Неопределено) Тогда
		Возврат Неопределено;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьТабЧастьДокумента()

// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	Если ТабЧасть = Неопределено Тогда // Нет такой таб. части в документе
		Возврат Ложь;
	Иначе
		Если ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			Возврат Ложь;
		Иначе
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	
	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));
	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);
	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);
	
КонецФункции // ПолучитьОписаниеТиповСтроки()	 

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность,РазрядностьДробнойЧасти=0) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Число"));
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность,РазрядностьДробнойЧасти);
	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);
	
КонецФункции // ПолучитьОписаниеТиповЧисла() 

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));
	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);
	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);
	
КонецФункции // ПолучитьОписаниеТиповДаты() 

// Служебная функция - возвращает принадлежность объекта метаданных определенному классу
// 
// Параметры:
//  Класс  - класс
//  Объект - объект метаданных
// 
Функция ПринадлежностьКлассуМетаданных(Класс, Объект) Экспорт
	Для Каждого МДОбъект Из Метаданные[Класс] Цикл
		Если МДОбъект = Объект Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции // ПринадлежностьКлассуМетаданных()

// Служебная функция, предназначенная для получения описания типов набора записей по объекту метаданных
// Параметры:
//  Объект - объект метаданных
//
// Возвращаемое значение:
// Описание типов с единственным типом набора записей
//
Функция ПолучитьОписаниеТиповНабораЗаписей(Объект) Экспорт
	
	Массив = Новый Массив;
	Если ПринадлежностьКлассуМетаданных("РегистрыРасчета", Объект) Тогда
		Массив.Добавить(Тип("РегистрРасчетаНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыБухгалтерии", Объект) Тогда
		Массив.Добавить(Тип("РегистрБухгалтерииНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыНакопления", Объект) Тогда
		Массив.Добавить(Тип("РегистрНакопленияНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыСведений", Объект) Тогда
		Массив.Добавить(Тип("РегистрСведенийНаборЗаписей."+Объект.Имя));
	КонецЕсли;
	Возврат Новый ОписаниеТипов(Массив);
	
КонецФункции  // ПолучитьОписаниеТиповНабораЗаписей()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

////////////////////////////////////////////////////////////////////////////////
//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Функция убирает из текста сообщения слущебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // ()


// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура СообщитьОбОшибке(ТекстСообщения, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт

	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);

	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено, ЗаполнитьПериод = истина) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРек.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;
	
	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());
	ЕстьПериод    = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;
	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл

		ИмяКолонки = Колонка.Имя;
		Если ИмяКолонки <> "Период"
		   И ИмяКолонки <> "Активность"
		   И ИмяКолонки <> "НомерСтроки"
		   И ИмяКолонки <> ""
		   И ?(ИмяКолонки = "ВидДвижения", ВидДвижения = Неопределено, Истина)
		   И ИмяКолонки <> "МоментВремени" Тогда
		   
			Если ИзмеренияСостТипа.Свойство(ИмяКолонки) Тогда
				ФлагКолонкиСостТипа = Истина;
			Иначе
				ФлагКолонкиСостТипа = Ложь;
			КонецЕсли;
			
			Индекс = 0;
			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл

				Если ПерваяКолонка Тогда
					
					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;
					
					МассивСтрок[Индекс] = СтрокаДвижения;
					СтрокаДвижения.Период = НаборДвижений.мПериод;
					Если не ЗаполнитьПериод и ЕстьПериод И НЕ СтрокаТаблицы.Период = '00010101' Тогда
						СтрокаДвижения.Период = СтрокаТаблицы.Период;
					Иначе
						СтрокаДвижения.Период = НаборДвижений.мПериод;
					КонецЕсли; 
					
				Иначе
					
					СтрокаДвижения = МассивСтрок[Индекс];
					
				КонецЕсли;
				
				Индекс = Индекс + 1;
				
				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда

					Очистить = Ложь;
					Если ТипЗнч(ЗначКолонки) = Тип("Число")Тогда
						Если ЗначКолонки = 0 Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Строка") Тогда
						Если ЗначКолонки = "" Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Дата") Тогда
						Если ЗначКолонки = '00010101000000' Тогда
							Очистить = Истина;
						КонецЕсли;
					ИначеЕсли ЗначКолонки = Неопределено Или ЗначКолонки.Пустая() Тогда
						Очистить = Истина;
					КонецЕсли;

					Если Очистить Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;
				
			КонецЦикла;
			
			ПерваяКолонка = Ложь;
			
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Получить движение(набор записей) для документа-объекта
//
// Параметры
//  Объект  – 	ДокументОбъект – Документ. для которого производится поиск движения
//  ТипДвижения  – Регистр<...>Менеджер – менеджер регистра, движение по которому пытаемся сформировать
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей   – набор записей для объекта
//
Функция ПолучитьДвижение(Объект, ТипДвижения, Сообщать=Ложь) Экспорт
	Движение = неопределено;
	Для каждого ТекДвижение из Объект.Движения цикл
		Если ТипЗнч(ТипДвижения.СоздатьНаборЗаписей()) = ТипЗнч(ТекДвижение) тогда
			Движение=ТекДвижение;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Сообщать и Движение = неопределено тогда
		СообщитьОбОшибке("Требуется подключение """+ТипЗНЧ(Объект)+""" к формированиям движения по регистру """+ТипЗнч(ТипДвижения)+"""!");
	КонецЕсли;
	Возврат Движение;
КонецФункции // ПолучитьДвижение()

// Получить набор записей по регистру по ссылке на документ
//
// Параметры
//  Ссылка  		– ДокументСсылка		– Ссылка на документ, для которого производится поиск движений по регистру (набора записей)
//  РегистрДвижения – Регистр<...>Менеджер	– менеджер регистра, движение по которому пытаемся обнаружить
//  ПрочитатьЗаписи - Булево 				- Прочитать существующий набор записей для документа (если документ может формировать движения по указанному регистру).
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей – Набор записей по регистру с отбором по документу,
//	 Неопределено 				в случае если документ не может формировать движений по регистру.
//
Функция ПолучитьНаборЗаписейПоСсылке(Ссылка, РегистрДвижения, ПрочитатьЗаписи = Ложь, Сообщать=Ложь) Экспорт
	Движения = неопределено;
	Если Ссылка.Метаданные().Движения.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(РегистрДвижения))) тогда
        Движения = РегистрДвижения.СоздатьНаборЗаписей();
		Движения.Отбор.Регистратор.Установить(Ссылка);
		Если ПрочитатьЗаписи тогда
			Движения.Прочитать();
		КонецЕсли;
	ИначеЕсли Сообщать тогда
			СообщитьОбОшибке("Требуется подключение документа """+Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).Представление()+""" к формированию движений по регистру """+
			СтрЗаменить(Лев(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":"))," менеджер","")+Сред(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":")+1)+
			"""!");
	КонецЕсли;
	
	Возврат Движения;
КонецФункции // ПолучитьДвижение()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОЧИХ ПОДСИСТЕМ, НЕ ИМЕЮЩИХ СВОИХ ОБЩИХ МОДУЛЕЙ

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(НЕ ЗначениеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(НЕ ЗначениеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если ЗначениеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции // ФорматСумм()

// Возвращает рабочую дату
//
// Возвращаемое значение:
//   Дата - рабочая дата
//
Функция ПолучитьРабочуюДату() Экспорт

#Если Клиент Тогда
	Дата = РабочаяДата;
#Иначе
	Дата = ТекущаяДата();
#КонецЕсли

	Возврат Дата;

КонецФункции // ПолучитьРабочуюДату()

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//  ИсхСумма   - распределяемая сумма
//  МассивКоэф - массив коэффициентов распределения
//  Точность   - точность округления при распределении. Необязателен.
//
//Возвращает:
//  МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//               суммы в соответствии с весом коэффициента (из массива коэффициентов)
//               В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//               или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина) Экспорт

	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	СуммаКоэф  = 0;

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	МассивСумм = Новый Массив(МассивКоэф.Количество());

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = ?(СуммаКоэф <> 0, Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1), 0);
		ИсхСумма = ИсхСумма - МассивСумм[К]; 
		СуммаКоэф = СуммаКоэф - МассивКоэф[К]; 
	КонецЦикла;

	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;

КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Процедура формирует таблицу значений со структурой для заполнения данными
// с информацией обращения в отдел технической поддержки
//
// Параметры:
//  ТаблицаДанных - таблица значений для заполнения
//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
//
Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт

	// Структура данных - таблица значений:
	//  Колонки:
	//   ИмяРездела
	//   ПредставлениеРаздела
	//   ДанныеРаздела
	
	// Структура данных раздела
	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
	//  Значение - Массив значений
	// 
	// Массив значений:
	//  [0] - Представление наименования параметра для печати
	//  [1] - Значение параметра

	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		ТаблицаДанных = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда
		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
	КонецЕсли; 
	ТаблицаДанных.Индексы.Добавить("ИмяРаздела");
	
	Если ФормаНастройкиПараметров = Неопределено Тогда
		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
	КонецЕсли;
	
	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл
		
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
		   И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
		   И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
		Если ПозицияРазделителяРаздела = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяРаздела = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");
		Если СтрокаРаздела = Неопределено Тогда
			СтрокаРаздела = ТаблицаДанных.Добавить();
			СтрокаРаздела.ИмяРаздела           = ИмяРаздела;
			Попытка
				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
			Исключение
				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
			КонецПопытки;
		КонецЕсли;
		
		МассивЗначений = Новый Массив;
		Попытка
			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
			Иначе
				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
			КонецЕсли; 
		Исключение
			МассивЗначений.Добавить(ЭлементФормы.Имя);
		КонецПопытки;
		МассивЗначений.Добавить("");
		
		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);
		
	КонецЦикла;
	
	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
	
КонецПроцедуры

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

	//ТекстВозврата = "";
	//
	//ТекстВозврата = ТекстВозврата + Символы.ПС;
	//ТекстВозврата = ТекстВозврата + Символы.ПС;
	//ТекстВозврата = ТекстВозврата + Символы.ПС + "============= Сведения об использовании ПП 1С:Предприятие 8 ============";
	//
	////ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	//
	//// Сформируем обязательный информационный раздел
	//
	//СистемИнфо = Новый СистемнаяИнформация;
	//
	//ТекстВозврата = ТекстВозврата + Символы.ПС;
	//ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	//ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8: "   + СистемИнфо.ВерсияПриложения;
	//ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	//ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
	//ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	//ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	//ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	//ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

	//НомерСтрокиРаздела = 1;
	//
	//Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
	//	
	//	Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
	//		
	//		СтрокаРаздела = "";
	//		
	//		Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
	//			Продолжить;
	//		КонецЕсли;
	//		
	//		Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
	//			Если НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
	//				Продолжить;
	//			КонецЕсли; 
	//			СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
	//		КонецЦикла; 
	//		
	//		Если НЕ ЗначениеЗаполнено(СтрокаРаздела) Тогда
	//			Продолжить;
	//		КонецЕсли;
	//		
	//		НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
	//		
	//		СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
	//		
	//		ТекстВозврата = ТекстВозврата + Символы.ПС;
	//		ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
	//	
	//	КонецЦикла;
	//	
	//КонецЕсли;
	//
	//Возврат ТекстВозврата;

КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА, ПЕРЕМЕННЫХ МОДУЛЯ ПРИЛОЖЕНИЯ

// Функция возвращает значение экспортных переменных модуля приложений из параметра сеанса
// Необходмо для возможности создания объектов на сервере
Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	// Значение в КЭШе не нашли, получим значение из БД
	Если ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда
		НайденноеЗначение = ПараметрыСеанса.ТекущийПользователь;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глСоответствиеТекстовЭлектронныхПисем") Тогда
			НайденноеЗначение = Новый Соответствие;				
			
	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("УчетнаяПолитикаПоУправленческомуУчету") Тогда
	//		НайденноеЗначение = СоздатьКЭШУчетнойПолитики("");
	//		
	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("УчетнаяПолитикаПоНалоговомуУчету") Тогда
	//		НайденноеЗначение = СоздатьКЭШУчетнойПолитики("НалоговыйУчет");
	//		
	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("ВалютаРегламентированногоУчета") Тогда
	//		НайденноеЗначение = Константы.ВалютаРегламентированногоУчета.Получить();
	//		
	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("ВалютаУправленческогоУчета") Тогда
	//		НайденноеЗначение = Константы.ВалютаУправленческогоУчета.Получить();

	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоОбменДанными") Тогда
	//	НайденноеЗначение = ПроцедурыОбменаДанными.ВыполнитьИнициализациюАвтообменаПриНачалеРаботы();
		
	#Если Клиент Тогда

	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОбработкаАвтоПолученияОтправкиЭлектронныхПисем") Тогда	
	//	Если ПравоДоступа("Использование", Метаданные.Обработки.АвтоПолучениеОтправкаЭлектронныхПисем) Тогда
	//		НайденноеЗначение = Обработки.АвтоПолучениеОтправкаЭлектронныхПисем.ПолучитьФорму();
	//	Иначе
	//		НайденноеЗначение = Неопределено;
	//	КонецЕсли;		

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("КэшСтратегииАвтонумерации") Тогда	
		НайденноеЗначение = Новый Соответствие;		
		
	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("ФормаОповещенияОЗадачах") Тогда	
	//	НайденноеЗначение = Задачи.ЗадачиПользователя.ПолучитьФорму("ФормаОповещенияОЗадачах", ,"Оригинал");
		
	#КонецЕсли

	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("глКоличествоСекундОпросаОбмена") Тогда
	//	НайденноеЗначение = Константы.ИнтервалДляОпросаРегламентныхЗаданийВФайловомВарианте.Получить();
	//	Если НайденноеЗначение = 0 Тогда
	//		НайденноеЗначение = 60;
	//	КонецЕсли;
	//			
	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("ЗначенияНастроекПольователей") Тогда
	//	НайденноеЗначение = Новый Соответствие;
	//	
	//ИначеЕсли ВРег(ИмяПараметра) = ВРег("ЗначенияДополнительныхПравПользователя") Тогда
	//	НайденноеЗначение = Новый Соответствие;
	
	Иначе
		СтрокаИсключения = "Невозможно обработать параметр " + """" + ИмяПараметра + """" + " для получения значения";
		ВызватьИсключение СтрокаИсключения;
	КонецЕсли;
	
	Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
	КэшИзменен = Истина;
	
	Возврат НайденноеЗначение;
	
КонецФункции

Процедура УстановитьЗначениеПеременной(ИмяПараметра, Кэш, ЗначениеПараметра, ОбновлятьВоВсехКэшах = Ложь) Экспорт
	
	Если Кэш.Свойство(ИмяПараметра) Тогда
		Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
	КонецЕсли;
	
	#Если Клиент ИЛИ ВнешнееСоединение Тогда
		Если ОбновлятьВоВсехКэшах Тогда
			КэшНаСервере = ПараметрыСеанса.ОбщиеЗначения.Получить();
			КэшНаСервере.Вставить(ИмяПараметра, ЗначениеПараметра);
			ПараметрыСеанса.ОбщиеЗначения = Новый ХранилищеЗначения(КэшНаСервере);
		КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ

Процедура УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, ПроверятьДвижения = Ложь)Экспорт
	// получение списка последовательностей в которых зарегистрирован документ
	Если ПроверятьДвижения Тогда
		ТаблицаРегистраций = ОпределитьНаличиеРегистрацииДокументаВПоследовательности(ДокументОбъект);
	КонецЕсли;      
	КоллекцияПоследовательностей = ДокументОбъект.ПринадлежностьПоследовательностям;
	Для Каждого НаборЗаписейРегистрацииВПоследовательности ИЗ КоллекцияПоследовательностей Цикл
		Если (НаборЗаписейРегистрацииВПоследовательности.Количество() > 0)
		  ИЛИ (ПроверятьДвижения И (НЕ ТаблицаРегистраций.Найти(НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя,"Имя") = Неопределено)) Тогда
		   НаборЗаписейРегистрацииВПоследовательности.Очистить();
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры//УдалитьРегистрациюДокументаВПоследовательностях

Функция ОпределитьНаличиеРегистрацииДокументаВПоследовательности(ДокументОбъект) Экспорт
	ТекстЗапроса = "";	
	
	Для Каждого Последовательность ИЗ ДокументОбъект.ПринадлежностьПоследовательностям Цикл
		// в запросе получаем имена последовательностей, в которых документ зарегистрирован
		ТекстЗапроса = ТекстЗапроса + "
		|" + ?(ТекстЗапроса = "", "", "ОБЪЕДИНИТЬ ВСЕ ") + "
		|ВЫБРАТЬ """ + Последовательность.Метаданные().Имя 
		+  """ КАК Имя ИЗ " + Последовательность.Метаданные().ПолноеИмя()  
		+ " ГДЕ Регистратор = &Регистратор";
		
	КонецЦикла;
	
	Если ТекстЗапроса = "" Тогда
		Возврат Новый ТаблицаЗначений();
	Иначе
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Регистратор", ДокументОбъект.Ссылка);
		ТаблицаЗапроса = Запрос.Выполнить().Выгрузить();	
		Возврат ТаблицаЗапроса;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс  ) Экспорт
	
	//Если ПараметрыСеанса.ИспользованиеРИБ Тогда
		//Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
	Префикс = Префикс;
	
КонецПроцедуры

Функция ОпределитьТекущийРежимРаботыМонопольный() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл
		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Процедура СообщитьИнформацияОПрефиксации() Экспорт
	
КонецПроцедуры

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Если МассивДанные = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		
		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
		
	КонецЦикла;
	
	// не нашли элемент
	Возврат -1;
	
КонецФункции

// РАБОТА С ПЕРЕМЕННЫМИ

// Меняет местами значения двух доступных для записи переменных
//
// Параметры
//  Источник - первая переменная
//  Приемник – вторая переменная
//
Процедура ПоменятьПеременныеМестами(Источник, Приемник) Экспорт

	тмп = Источник;
	Источник = Приемник;
	Приемник = Тмп;

КонецПроцедуры // ПоменятьПеременныеМестами()

// Отбирает из переданной таблицы строки по заданным критериям.
//
// Параметры:
//  Источник - ТаблицаЗначений, РезультатЗапроса, ОбластьЯчеекТабличногоДокумента. Таблица-источник.
//  СтруктураКритериев - Структура. Названия отборов и значения, по которым нужно отобрать строки.
//  СтруктураСложныхКритериев - Структура. Если свойство передано, то значение содержит вид сравнения.
//
// Возвращаемое значение:
//  РезультатЗапроса - таблица с нужными строками.
//
Функция ОтобратьСтрокиПоКритериям(Источник, СтруктураКритериев, СтруктураСложныхКритериев = Неопределено) Экспорт

	Перем ВидСравненияСложный;

	Если СтруктураСложныхКритериев = Неопределено Тогда
		СтруктураСложныхКритериев = Новый Структура;
	КонецЕсли;

	ПостроительЗапроса = Новый ПостроительЗапроса;
	ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(Источник);

	Для Каждого Критерий Из СтруктураКритериев Цикл
		НовыйОтбор = ПостроительЗапроса.Отбор.Добавить(Критерий.Ключ);

		СтруктураСложныхКритериев.Свойство(Критерий.Ключ, ВидСравненияСложный);

		Если ВидСравненияСложный = Неопределено Тогда
			НовыйОтбор.Установить(Критерий.Значение);
		Иначе
			НовыйОтбор.Использование = Истина;
			НовыйОтбор.ВидСравнения = ВидСравненияСложный;
			НовыйОтбор.Значение = Критерий.Значение;
		КонецЕсли;
	КонецЦикла;

	Возврат ПостроительЗапроса.Результат;

КонецФункции // ОтобратьСтрокиПоКритериям()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА

// Вспомогательная функция для определнения условий запроса в механизме
// изменения порядка следования элементов. Ставит условия на родителя и владельца
//
// Параметры
//  Элемент - СправочникСсылка, для которого необходимо изменить порядок
//  Запрос - Запрос, в который дописываем условия
// 
//  Возвращаемое значение:
//   Строка - условие запроса
// 
Функция ПолучитьДополнениеЗапроса(Элемент, Запрос, БезПервогоИ = Ложь)

	ТекстЗапроса = "";
	
	Если Элемент.Метаданные().Иерархический = Истина Тогда
		Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
		Если НЕ БезПервогоИ Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";
	КонецЕсли; 
	
	Если Элемент.Метаданные().Владельцы.Количество() > 0 Тогда
		Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
		Если НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ) Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";
	КонецЕсли; 

	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает значение порядка для нового элемента справочника.
//
// Параметры
//  ЭлементОбъект - СправочникОбъект - новый объект
//
// Возвращаемое значение:
//   Число - новый порядок
//
Функция НазначитьНовыйПорядок(ЭлементОбъект)

	ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";
	
	ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
	
	Если НЕ ПустаяСтрока(ДополнениеЗапроса) Тогда
		Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";
	КонецЕсли; 
	
	Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат (Выборка.Порядок + 1)
	КонецЕсли; 

КонецФункции

// Процедура вызывается перед записью объекта, для которого необходимо
// контролировать порядок элементов.
// 
// Параметры
//  Отказ - Булево, отказ от записи объекта
//  ЭтотОбъект - СправочникОбъект
//  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
//
Процедура ПередЗаписьюОбъектаПорядка(Отказ, ЭтотОбъект, КонтролироватьПорядок) Экспорт

	Если ЭтотОбъект.ЭтоНовый() Тогда
		ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
	Иначе
		Если ЭтотОбъект.Ссылка.Родитель <> ЭтотОбъект.Родитель ИЛИ ЭтотОбъект.Ссылка.Владелец <> ЭтотОбъект.Владелец Тогда
			ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
		КонецЕсли;
	КонецЕсли;
	
	Если КонтролироватьПорядок Тогда
	
		ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
		
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";
		
		Если НЕ ЭтотОбъект.ЭтоНовый() Тогда
			Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
			Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";
		КонецЕсли; 
		
		Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			Отказ = Истина;
			#Если Клиент Тогда
				Сообщить("Не уникальный порядок элемента справочника.");
			#КонецЕсли
		КонецЕсли;
	
	КонецЕсли; 

КонецПроцедуры

// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
// порядком следования.
// 
// Параметры:
//  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
Процедура ИзменитьПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина) Экспорт
	
	ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);
	
	Если ЭлементЗамены = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НовыйПорядокЗамены   = ЭлементЗамены.Порядок;
	НовыйПорядокЭлемента = ЭлементСсылка.Порядок;
	
	Если НаправлениеПорядка = "Вверх" Тогда
		Если НовыйПорядокЗамены < НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены + 1;
		КонецЕсли; 
	Иначе
		Если НовыйПорядокЗамены > НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены - 1;
		КонецЕсли;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	ФиксироватьТранзакцию = Истина;
	
	Если НовыйПорядокЗамены <> ЭлементЗамены.Порядок Тогда
		ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();
		ОбъектЗамены.Порядок = НовыйПорядокЗамены;
		ОбъектЗамены.КонтролироватьПорядок = Ложь;
		Попытка
			ОбъектЗамены.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли; 
	
	Если ФиксироватьТранзакцию Тогда
		ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();
		ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;
		Попытка
			ОбъектЭлемента.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если ФиксироватьТранзакцию Тогда
		ЗафиксироватьТранзакцию();
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли; 
	
КонецПроцедуры

// Функция определяет элемент справочника, с которым необходимо
// произвести "рокировку" текущего элемента
//
// Параметры
//  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
// Возвращаемое значение:
//   СправочникСсылка
//
Функция ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг)

	ТекущийПорядок = ЭлементСсылка.Порядок;
	
	ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СправочникПорядка.Ссылка
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
	|ГДЕ
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
		
	ИначеЕсли ЦиклическийСдвиг Тогда
		// Текущий элемент или первый (при движении вверх)
		// или последний (при движении вниз)
		// или вообще единственный
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Ссылка
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", ">", "<") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
		|УПОРЯДОЧИТЬ ПО
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
		|";
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Возврат Неопределено;
		Иначе
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			Возврат Выборка.Ссылка;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ


// функция возвращает часть строки после последнего встреченного символа в строке
Функция ПолучитьЧастьСтрокиОтделеннойСимволом(Знач ИсходнаяСтрока, Знач СимволПоиска)
	
	ПозицияСимвола = СтрДлина(ИсходнаяСтрока);
	Пока ПозицияСимвола >= 1 Цикл
		
		Если Сред(ИсходнаяСтрока, ПозицияСимвола, 1) = СимволПоиска Тогда
						
			Возврат Сред(ИсходнаяСтрока, ПозицияСимвола + 1); 
			
		КонецЕсли;
		
		ПозицияСимвола = ПозицияСимвола - 1;	
	КонецЦикла;

	Возврат "";
  	
КонецФункции

// Выделяет из имени файла его расширение (набор символов после последней точки).
//
// Параметры
//  ИмяФайла     – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьРасширениеФайла(Знач ИмяФайла) Экспорт
	
	Расширение = ПолучитьЧастьСтрокиОтделеннойСимволом(ИмяФайла, ".");
	Возврат Расширение;
	
КонецФункции

// Выделяет из полного пути к файлу его имя (набор символов после последней \).
//
// Параметры
//  ПутьКФайлу     – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьИмяФайлаИзПолногоПути(Знач ПутьКФайлу) Экспорт
	
	ИмяФайла = ПолучитьЧастьСтрокиОтделеннойСимволом(ПутьКФайлу, "\");
	Возврат ИмяФайла;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С XML

// Функция осуществляет построение дерева XML.
//
// Параметры
//  XML             - <ЧтениеXML>
//                  - Объект, при помощи которого осуществляется чтение
//                    файла отчета.
//
//  Дерево          - <Структура>
//                  - Дерево XML.
//
//  ПервыйВызов     - <Булево>
//                  - Служебный параметр.
//
// Возвращаемое значение:
//  <Булево>        - Результат выполнения.
//
Функция ПостроитьДеревоXML(XML, Дерево, ПервыйВызов = Истина) Экспорт

	Результат = Истина;
	Имя       = "";
	Врем      = Неопределено;
	Врем2     = Неопределено;
	Врем3     = Неопределено;

	Если ПервыйВызов Тогда
		Дерево = Новый Структура();
	КонецЕсли;

	Если XML.Прочитать() Тогда
		Если XML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Имя  = XML.ЛокальноеИмя;
			Врем = Новый Структура();
			Пока ПостроитьДеревоXML(XML, Врем, Ложь) Цикл
			КонецЦикла;
			Пока XML.Имя <> Имя Цикл
				Если XML.ТипУзла = ТипУзлаXML.Текст Тогда
					Врем = XML.Значение;
				КонецЕсли;
				Если Не XML.Прочитать() Тогда
					Результат = Ложь;
					Возврат Результат;
				КонецЕсли;
			КонецЦикла;
			Дерево.Свойство(Имя, Врем2);
			Если Врем2 = Неопределено Тогда
				Врем2 = Врем;
			Иначе
				Если ТипЗнч(Врем2) = Тип("Массив") Тогда
					Врем2.Добавить(Врем);
				Иначе
					Врем3 = Новый Массив();
					Врем3.Добавить(Врем2);
					Врем3.Добавить(Врем);
					Врем2 = Врем3;
				КонецЕсли;
			КонецЕсли;
			Дерево.Вставить(Имя, Врем2);
		Иначе
			Результат = Ложь;
		КонецЕсли;
	Иначе
		Результат = Ложь;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПостроитьДеревоXML()

// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УЧЕТНОЙ ПОЛИТИКОЙ

// Функция применяется при необходимости получить сведения об учетной политике организации.
//
// Параметры:
// Учет - строка. Определяет регистр сведений, из которого будут получены данные:
//   "НалоговыйУчет" или "БухгалтерскийУчет".
//
// Возвращаемое значение - таблица значений. Таблица, каждая строка которой 
//  соответствует записи регистра. 
//
Функция СоздатьКЭШУчетнойПолитики(Учет) Экспорт

	Запрос = Новый Запрос("
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	*
	|ИЗ
	|	РегистрСведений.УчетнаяПолитика" + Учет + "
	|УПОРЯДОЧИТЬ ПО
	|	Период
	|");

	Возврат Запрос.Выполнить().Выгрузить();

КонецФункции // СоздатьКЭШУчетнойПолитики()

// Функция возвращает структуру с параметрами учетной политики на заданную дату.
//
Функция ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация = Неопределено, Учет = "Упр", СообщатьОбОшибке = Истина) Экспорт
	
	СтруктураУчПолитика = Новый Структура;
			
	Если Учет <> "Упр" И НЕ ЗначениеЗаполнено(Организация) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;
		
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(КонДата) Тогда
		
		Отказ = Истина;
		Возврат СтруктураУчПолитика;	
		
	КонецЕсли;

	Если Учет = "Нал" Тогда		
		УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаПоНалоговомуУчету");		
	ИначеЕсли Учет = "Упр" Тогда
		УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаПоУправленческомуУчету");
	КонецЕсли; 
		
	Если Учет = "Упр" Тогда
		
		Если УчетнаяПолитика.Количество() = 0 Тогда
			Отказ = Истина;
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке("Не указаны параметры учетной политики управленческого учета на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			КонецЕсли;	
			Возврат СтруктураУчПолитика;	
		Иначе
				
			Номер = 0;
			ФлагОтказа = Истина;
			Для НомерСтроки = 1 По УчетнаяПолитика.Количество() Цикл
					
				Строка = УчетнаяПолитика.Получить(НомерСтроки - 1);
				Если Строка.Период <= КонДата Тогда
					Номер = НомерСтроки;
					ФлагОтказа = Ложь;
						
				Иначе 
					Прервать;
				КонецЕсли;
			КонецЦикла;
				
			Если Номер <> 0 Тогда
				Строка = УчетнаяПолитика.Получить(Номер - 1);
				Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
					СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
				КонецЦикла;
					
			КонецЕсли;
				
		КонецЕсли;
		
	Иначе
		
		УчетнаяПолитикаОрганизации = УчетнаяПолитика.НайтиСтроки(Новый Структура("Организация", Организация));
		
		Если УчетнаяПолитикаОрганизации.Количество() = 0 Тогда
			Отказ = Истина;
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке("Не указаны параметры учетной политики налогового учета ("+СокрЛП(Организация)+") на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			КонецЕсли;	
			Возврат СтруктураУчПолитика;	
		Иначе
				
			Номер = 0;
			ФлагОтказа = Истина;
			Для НомерСтроки = 1 По УчетнаяПолитикаОрганизации.Количество() Цикл
					
				Строка = УчетнаяПолитикаОрганизации.Получить(НомерСтроки - 1);
				Если Строка.Период <= КонДата Тогда
					Номер = НомерСтроки;
					ФлагОтказа = Ложь;
						
				Иначе 
					Прервать;
				КонецЕсли;
			КонецЦикла;
				
			Если Номер <> 0 Тогда
				Строка = УчетнаяПолитикаОрганизации.Получить(Номер - 1);
				Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
					СтруктураУчПолитика.Вставить(Колонка.Имя, Строка[Колонка.Имя]);
				КонецЦикла;
			КонецЕсли;
				
		КонецЕсли;
		
	КонецЕсли;
		
	Если ФлагОтказа = Истина Тогда
		Отказ = Истина;
		Если СообщатьОбОшибке Тогда
			Если Учет = "Упр" Тогда
				СообщитьОбОшибке("Не указаны параметры учетной политики управленческого учета на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			Иначе
				СообщитьОбОшибке("Не указаны параметры учетной политики налогового учета ("+СокрЛП(Организация)+") на " + Формат(КонДата, "ДЛФ=DD"), Отказ);
			КонецЕсли;
		КонецЕсли;	
		Возврат СтруктураУчПолитика;
	КонецЕсли; 
		
	Возврат СтруктураУчПолитика;
		
КонецФункции // ПолучитьПараметрыУчетнойПолитики()

// Функция дополняет структуру шапки документа положениями учетной политики.
//
Процедура ДополнитьПоложениямиУчетнойПолитики(СтруктураШапкиДокумента, КонДата, Отказ, Организация, Учет = "Нал", СтруктураПолейУчетнойПолитикиНУ = неопределено) Экспорт
	СтруктураУП = ПолучитьПараметрыУчетнойПолитики(КонДата, Отказ, Организация, Учет);
	
	Для каждого ПараметрУП Из СтруктураУП Цикл
		Если (ТипЗнч(СтруктураПолейУчетнойПолитикиНУ) = Тип("Структура"))
		   И НЕ (СтруктураПолейУчетнойПолитикиНУ.Количество() = 0) Тогда
			// Заполнение определенными полями
			Если СтруктураПолейУчетнойПолитикиНУ.Свойство(ПараметрУП.Ключ) Тогда
				Если НЕ ЗначениеЗаполнено(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ]) Тогда
					СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);
				Иначе
					СтруктураШапкиДокумента.Вставить(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ],ПараметрУП.Значение);
				КонецЕсли; 
			КонецЕсли; 
		Иначе	
			// Дополняем всеми параметрами учетной политики
			СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);  
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры // ДополнитьПоложениямиУчетнойПолитики()

// Процедура копирует значения одной строки таблицы значеницй в другую
// структура колонок должна совпадать
//
// Параметры:
//		СтрокаПриемник - строка в которую копируем
//		СтрокаИсточник - строка из которой копируем
//      ИменаКол - имена колонок, разделенные запятыми, которые надо скопировать
//                 необязателен. По умолчанию - все колонки
//
Процедура КопироватьСтрокуТаблицыЗначений(СтрокаПриемник, СтрокаИсточник, ИменаКол) Экспорт

	Если ТипЗнч( ИменаКол) = Тип("ТаблицаЗначений") Тогда
		СписокСвойств = "";
		Для Каждого Кол Из ИменаКол.Колонки Цикл
			Если Не Кол.Имя = "НомерСтроки" Тогда
				Если Не ПустаяСтрока(СписокСвойств) Тогда
					СписокСвойств = СписокСвойств + ",";	
				КонецЕсли;
				СписокСвойств = СписокСвойств + Кол.Имя;
			КонецЕсли;
		КонецЦикла;
		ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, СписокСвойств,);
	Иначе // Строка с именами колонок
        ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, ИменаКол,);
	КонецЕсли;

КонецПроцедуры // КопироватьСтрокуТаблицыЗначений()

// Процедура выполняет обработку признака отражения в регламентированном учете для объекта документа.
//
// Параметры:
//  Объект                  - Документ-объект
//  ИмяОтражатьВБУ          - имя элемента формы, связанного с реквизитом ОтражатьВБУ
//  ИмяОтражатьВНУ          - имя элемента формы, связанного с реквизитом ОтражатьВНУ
//  мОтражатьВРегламентированномУчете - переменная формы, передается в процедуру для изменения.
//   далее может использоваться в логике формы в индивидуальном порядке для каждого документа.
//  флИзменятьРеквизитыБУНУ - признак необходимости изменять реквизиты документа ОтражатьвБУ, ОтражатьВНУ
//                            Устанавливается если процедура вызывается при изменении значения организации в документе
Процедура ОбработатьПризнакОтраженияВреглУчете(Объект, ИмяОтражатьВБУ = "ОтражатьВБухгалтерскомУчете",ИмяОтражатьВНУ = "ОтражатьВНалоговомУчете",мОтражатьВРегламентированномУчете,флИзменятьРеквизитыБУНУ=ложь) Экспорт

	//мОтражатьВРегламентированномУчете = Объект.Организация.ОтражатьВРегламентированномУчете;

//	Если флИзменятьРеквизитыБУНУ или Объект.ЭтоНовый() Тогда
//		Если мОтражатьВРегламентированномУчете Тогда
//			ТекПользователь = ПараметрыСеанса.ТекущийПользователь;
//			//организация в РУ отражается. Флаги БУ и НУ необходимо установить в соотв. с настройками пользователя по умолчанию
//			Объект.ОтражатьВБухгалтерскомУчете=УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОтражатьДокументыВБухгалтерскомУчете");
//			Если ИмяОтражатьВНУ<>"" Тогда
//				Если Объект.ОтражатьВБухгалтерскомУчете Тогда
//					Объект.ОтражатьВНалоговомУчете = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекПользователь, "ОтражатьДокументыВНалоговомУчете");
//				Иначе
//					Объект.ОтражатьВНалоговомУчете = ложь;
//				КонецЕсли;
//			КонецЕсли;
//		Иначе
//			//организация в РУ не отражается - необходимо сбросить флаги отражения в БУ и НУ
//			Если Объект.ОтражатьВБухгалтерскомУчете  Тогда
//				Объект.ОтражатьВБухгалтерскомУчете = Ложь;
//			КонецЕсли;
//			Если ИмяОтражатьВНУ<>"" Тогда
//				Если Объект.ОтражатьВНалоговомУчете Тогда
//					Объект.ОтражатьВНалоговомУчете = Ложь;
//				КонецЕсли;
//			КонецЕсли;
//		КонецЕсли;
//	КонецЕсли;

КонецПроцедуры // ОбработатьПризнакОтраженияВреглУчете()

// Процедура управляет доступностью признаков отражения в БУ и НУ в документах в зависимости от реквизита организации 
// ОтражатьВРегламентированномУчете. Также процедура может изменять значения реквизитов ОтражатьВБУ и ОтражатьВНУ
// Может вызываться из обработчиков формы ПриОткрытии, ОрганизацияПриИзменении
//
//Параметры:
//  Объект                  - Документ-объект
//  Форма                   - форма документа
//  ИмяОтражатьВБУ          - имя элемента формы, связанного с реквизитом ОтражатьВБУ
//  ИмяОтражатьВНУ          - имя элемента формы, связанного с реквизитом ОтражатьВНУ
//  мОтражатьВРегламентированномУчете - переменная формы, передается в процедуру для изменения.
//    далее может использоваться в логике формы в индивидуальном порядке для каждого документа.
//  флИзменятьРеквизитыБУНУ - признак необходимости изменять реквизиты документа ОтражатьвБУ, ОтражатьВНУ
//                            Устанавливается если процедура вызывается при изменении значения организации в документе
Процедура УправлениеПризнакомОтраженияВРеглУчете(Объект, Форма,ИмяОтражатьВБУ = "ОтражатьВБухгалтерскомУчете",ИмяОтражатьВНУ = "ОтражатьВНалоговомУчете",мОтражатьВРегламентированномУчете,флИзменятьРеквизитыБУНУ=ложь) Экспорт

КонецПроцедуры

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ФОРМИРОВАНИЕ КПП НА БАЗЕ ИНН


//Предназначена для получения массива пустых значений, содержащих значение Неопределено и значения переданного типа или описания типов
Функция МассивПустыхЗначений(ОписаниеТипов) Экспорт
	МассивЗначений = новый Массив;
	МассивЗначений.Добавить(неопределено);
	Если ТипЗнч(ОписаниеТипов)=Тип("ОписаниеТипов") Тогда
		Для каждого Тип из ОписаниеТипов.Типы() Цикл
			МассивЗначений.Добавить(ПустоеЗначениеТипа(Тип));
		КонецЦикла;
	ИначеЕсли ТипЗнч(ОписаниеТипов)=Тип("Тип") Тогда	
		МассивЗначений.Добавить(ПустоеЗначениеТипа(ОписаниеТипов));
	КонецЕсли;
	
	Возврат МассивЗначений;

КонецФункции

//возвращает значение реквизита в строке табличной части с проверкой на существование данного реквизита
Функция ПолучитьЗначениеРеквизитаТЧ(МетаданныеДокумента, ИмяТабличнойЧасти, СтрокаТабличнойЧасти, ИмяРеквизита, ПустоеЗначение = Неопределено) Экспорт

	ЗначениеРеквизита = ?(ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабличнойЧасти),
	                      СтрокаТабличнойЧасти.ХарактеристикаНоменклатуры, ПустоеЗначение);

	Возврат ЗначениеРеквизита;

КонецФункции // ПолучитьЗначениеРеквизитаТЧ()

// Если в шапке переданного документа есть реквизит с указанным именем, то возвращается его значение.
// Если такого реквизита нет - возвращается Неопределено.
//
// Параметры:
//  ИмяРеквизита - Строка. Имя искомого реквизита.
//  ДокументОбъект - объект переданного документа.
//  МетаданныеДокумента - Метаданные переданного документа.
//  ПустоеЗначение - значение, которое должно вернуться, если в шапке нет такого реквизита,
//  если не передано, то возвращается значение Неопределено.
//
// Возвращаемое значение:
//  Значение реквизита - значение найденного реквизита или ПустоеЗначение.
//
Функция ПолучитьРеквизитШапки(ИмяРеквизита, ДокументОбъект, МетаданныеДокумента, ПустоеЗначение = Неопределено) Экспорт

	ЗначениеРеквизита = ?(ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента),
	                      ДокументОбъект[ИмяРеквизита], ПустоеЗначение);

	Возврат ЗначениеРеквизита;

КонецФункции // ПолучитьРеквизитШапки()

// Процедура заполняет структуру таблиц документа, значением которое будет одинаковым для всех таблиц (например значением шапки документа)
//
// Параметры:
//  СтруктТаблицДокумента   - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//  ИмяПоля                 - имя колонки в таблицах локумента, в которую будет установлено новое значение
//  УстанавливаемоеЗначение - значение, которое надо установить в таблицы документа
//  СтрТабЧасти             - имена таб. частей документа в которые необходимо установить новое значение. строка, в которой
//                            имена таб. частей разделены запятыми. необязательный параметр, по умолчанию - все таблицы.
//
Процедура УстановитьЗначениеВТаблицыДокумента(СтруктТаблицДокумента, ИмяПоля, УстанавливаемоеЗначение, СтрТабЧасти = "") Экспорт
	
	СтруктТабЧасти = ?( ПустаяСтрока(СтрТабЧасти), СтруктТаблицДокумента, Новый Структура(СтрТабЧасти));
	Для Каждого ТабЧасть Из СтруктТабЧасти Цикл
	
		Если СтруктТаблицДокумента[ТабЧасть.Ключ].Количество() > 0 Тогда
		    СтруктТаблицДокумента[ТабЧасть.Ключ].ЗаполнитьЗначения( УстанавливаемоеЗначение, ИмяПоля);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры // УстановитьЗначениеВТаблицыДокумента()

// Процедура формирует движение в регистр на основании данных в таблицах документов
//
//Параметры:
//  Движение              - движение документа, в которое необходимо произвести добавление записей (т.е. регистр)
//  ВидДвижения           - вид движения накопления (приход/расход)
//  СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//  ДатаДвижения          - дата на которую будут формироваться записи
//
Процедура ЗаписатьТаблицыДокументаВРегистр(Движение, ВидДвижения, СтруктТаблицДокумента, ДатаДвижения) Экспорт
	
	Движение.мПериод = ДатаДвижения;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
	
		Если ТабЧасть.Значение.Количество() = 0 Тогда
			Продолжить; // Пропускаем пустые табличные части
		КонецЕсли;
		
		Движение.мТаблицаДвижений = ТабЧасть.Значение;
		Если ВидДвижения = Неопределено Тогда // Регистр сведений
			ВыполнитьДвижениеПоРегистру(Движение);
		Иначе // Регистр накопления
			ВыполнитьДвижениеПоРегистру(Движение, ВидДвижения);
		КонецЕсли;
	
	КонецЦикла;

КонецПроцедуры // ЗаписатьТаблицыДокументаВРегистр()

// Функция загружает таблицы документа в таблицы соответствующие структуре регистров
//
// Параметры:
//  Движение - движение документа (т.е. регистр)
//  СтруктТаблицДокумента - структура содержашая таблицы документа. ключ - имя таблицы, значение - таблица значений с данными документа.
//
// Возвращаемое значение:
//  Структура, в которой ключ - это имя таблицы документа, соответствующий параметру СтруктТаблицДокумента,
//  значение - таблица значений, со структурой соответствующей структуре параметра (т.е. регистра) Движение
//  В таблицы значений данные загружаются по соответствию с имен полей.
//
Функция ЗагрузитьТаблицыДокументаВСтруктуру(Движение, СтруктТаблицДокумента) Экспорт
	
	ПустаяТабРегистра = Движение.Выгрузить();
	ПустаяТабРегистра.Очистить();
	
	СтруктДанных = Новый Структура;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
	
		ТабРегистра = ПустаяТабРегистра.Скопировать();
		
		Если ТабЧасть.Значение <> Неопределено И ТабЧасть.Значение.Количество() > 0 Тогда
			ЗагрузитьВТаблицуЗначений( ТабЧасть.Значение, ТабРегистра);
		КонецЕсли;
		
		СтруктДанных.Вставить( ТабЧасть.Ключ, ТабРегистра);
		
	КонецЦикла;
	
	Возврат СтруктДанных;

КонецФункции // ЗагрузитьТаблицыДокументаВСтруктуру()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА

// Функция разбирает строку вида например:
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = Найти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = Найти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	Если Структура.ТипОбъекта = "Документ" Тогда
		Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
	Иначе
		Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
	КонецЕсли;
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()

// Функция выбирает данные из критерия указанного отбора.
// Формирует и выполняет запрос. Выбирает указанные поля.
//
// Параметры:
//  КритерийОтбора - строка, имя критерия отбора
//  ЗначениеКритерияОтбора - произвольный, значение отбора.
//  СтруктураПолей - Структура, список полей для выбора
//
// Возвращаемое значение:
//  Данные критерия отбора - ВыборкаИзРезультатаЗапроса.
//
Функция ВыборДанныхИзКритерияОтбора(КритерийОтбора, ЗначениеКритерияОтбора, СтруктураПолей) Экспорт
	
	Запрос = Новый Запрос;
	ТекстЗапроса = "";
	
	Для Каждого ЭлементСостава ИЗ Метаданные.КритерииОтбора[КритерийОтбора].Состав Цикл
		
		ПутьКДанным = ЭлементСостава.ПолноеИмя();
		СтруктураПутьКДанным = РазобратьПутьКОбъектуМетаданных(ПутьКДанным);
		
		ЕСли НЕ ПравоДоступа("Чтение", СтруктураПутьКДанным.Метаданные) Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаДанных = "Ссылка, #Проведен, #ПометкаУдаления, #Дата, #Номер";

		Для Каждого ПолеЗапроса ИЗ СтруктураПолей Цикл
			
			ЕстьРеквизит = (СтруктураПутьКДанным.Метаданные.Реквизиты.Найти(ПолеЗапроса.Ключ) <> Неопределено);
			
			Если ЕстьРеквизит Тогда
				СтрокаДанных = СтрокаДанных + ", " + "#" + ПолеЗапроса.Ключ + " КАК " + ПолеЗапроса.Ключ;
			Иначе
				СтрокаДанных = СтрокаДанных + ", " + "NULL" + " КАК " + ПолеЗапроса.Ключ;
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтруктураПутьКДанным.ПутьКДанным = "ТабличнаяЧасть" Тогда
			ПрефиксПоля = "Ссылка.";
		Иначе
			ПрефиксПоля = "";
		КонецЕсли;
		
		ТекущаяСтрокаДанных = СтрЗаменить(СтрокаДанных, "#", ПрефиксПоля);
		ИмяОбъекта = СтруктураПутьКДанным.ТипОбъекта + "." + СтруктураПутьКДанным.ВидОбъекта;
			
		ТекущаяСтрокаГДЕ = "ГДЕ " + ИмяОбъекта + "." 
						   + СтруктураПутьКДанным.ИмяТаблЧасти + "." +СтруктураПутьКДанным.ИмяРеквизита + " = &ЗначениеКритерияОтбора";
		
		ИмяТЧ = Лев(СтруктураПутьКДанным.ИмяРеквизита, Найти(СтруктураПутьКДанным.ИмяРеквизита, ".")-1);
		ИмяРеквизита = Лев(СтруктураПутьКДанным.ИмяРеквизита, Найти(СтруктураПутьКДанным.ИмяРеквизита, ".")-1);
		
		ТекстЗапроса = ТекстЗапроса + ?(ТекстЗапроса = "", "ВЫБРАТЬ ", "ОБЪЕДИНИТЬ
		|ВЫБРАТЬ") + "
		|" + ТекущаяСтрокаДанных + " ИЗ " + ИмяОбъекта + "." + СтруктураПутьКДанным.ИмяТаблЧасти + "
		|" + СтрЗаменить(ТекущаяСтрокаГДЕ, "..", ".") + "
		|";
		
	КонецЦикла;
	
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ * ИЗ ( " + ТекстЗапроса + " ) КАК Документы УПОРЯДОЧИТЬ ПО Документы.Дата";
	
	Запрос.УстановитьПараметр("ЗначениеКритерияОтбора", ЗначениеКритерияОтбора);
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции // ВыборДанныхИзКритерияОтбора()

Функция ПолучитьТипИзмеренияПоУмолчанию(ТипЗначения) Экспорт
	
	Для каждого Тип Из ТипЗначения.Типы() Цикл
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМетаданных = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если Метаданные.Справочники.Найти(ОбъектМетаданных.Имя) <> Неопределено
		   И ОбъектМетаданных.Иерархический Тогда
			Возврат ТипИзмеренияПостроителяОтчета.Иерархия;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТипИзмеренияПостроителяОтчета.Элементы;
	
КонецФункции

// Функция определяет наличие клиентских подключений к базе других пользователей
Функция ЕстьДругиеПользователиВБазе() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда			
			Возврат Истина;						
		КонецЕсли;		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // глРазложить

// Процедура очистки введенного кода/номера объекта
// Параметры
//  ЭтотОбъект  - объект.
//	КодНомер - имя обрабатываемого реквизита (Код или Номер)
//  ПодменюДействия - меню "Действия" командной панели формы. В этот меню должен присутствовать пункт "Редактировать код/номер"
//  ПолеВводаНомера - поле вводе, связанное с кодом/номером объекта
//
Процедура СброситьУстановленныйКодНомерОбъекта(ЭтотОбъект, КодНомер, ПодменюДействия = Неопределено, ПолеВводаНомера = Неопределено) Экспорт
	//ОбщегоНазначения.УстановитьПустойКодНомерОбъекту(ЭтотОбъект, КодНомер);
	//#Если Клиент Тогда
	//	РаботаСДиалогами.ОбновитьПодсказкуКодНомерОбъекта(ЭтотОбъект.Метаданные(), ПодменюДействия, ПолеВводаНомера);
	//#КонецЕсли
КонецПроцедуры // СброситьУстановленныйКодНомерОбъекта()

Процедура УстановитьПустойКодНомерОбъекту(Объект, КодНомер) Экспорт
	Объект[КодНомер] = "";
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ УПРАВЛЕНИЯ ПЕРСОНАЛОМ

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ФамилияИнициалыФизЛица(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	ТипОбъекта = ТипЗнч(Объект);
	Если ТипОбъекта = Тип("Строка") Тогда
		ФИО = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или ТипОбъекта = Тип("СправочникОбъект.ФизическиеЛица") Тогда 
		ФИО = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект.Наименование)," ");
	Иначе
		
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"")
	КонецЕсли;
			
	КоличествоПодстрок = ФИО.Количество();
	Фамилия = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя		= ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество= ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"");

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИСПОЛЬЗУЮТСЯ АЛГОРИТМАМИ НАЛОГОВОГО УЧЕТА

// Служебная функция, предназначенная для получения описания типов набора записей по объекту метаданных
// Параметры:
//	Значение - Null, Булево, Строка
//
// Возвращаемое значение:
// Число, полученное в результате преобразования
//
Функция ПреобразоватьВЧисло(Значение) Экспорт
	
	Если (Значение = Null) или (Значение = Неопределено) Тогда
		
		Возврат 0
		
	Иначе
		
		Попытка
			
			Возврат Число(Значение)
			
		Исключение
			
			Возврат 0
			
		КонецПопытки
		
	КонецЕсли;
	
	
КонецФункции // ПреобразоватьВЧисло()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ПОГРЕШНОСТЕЙ ОКРУГЛЕНИЯ

// Выполняет округление числовых значений с накоплением погрешностей округления, образовавшихся
//		в результате предыдущих вызовов функции
//
// Параметры
//  Число 		– Число. Округляемое значение
//  Точность	– Число. Точность округления
//	Погрешность	- Число. Переменная, в которой накапливается погрешность с предыдущих вызовов
//
// Возвращаемое значение:
//   Число   – округленное значение
//
Функция ОкруглитьСУчетомПогрешности(Число, Точность, Погрешность = 0, 
	               СоответствиеПогрешностей = Неопределено, Ключ = Неопределено) Экспорт

	Если ЗначениеЗаполнено(СоответствиеПогрешностей) И ЗначениеЗаполнено(Ключ) Тогда
	
		// считываем погрешность округления, накопленную ранее при расчетах
		Погрешность = СоответствиеПогрешностей[Ключ];
		// погрешности округления еще нет -- первая сумма
		Если Погрешность = Неопределено Тогда
			Погрешность = 0;
		КонецЕсли;
		// округлим с учетом погрешности
		Округленное = ОкруглитьСУчетомПогрешности(Число, Точность, Погрешность);
		// сохраним погрешность округления
		СоответствиеПогрешностей.Вставить(Ключ, Погрешность);
	
	Иначе
		
		Если Число = 0 Тогда
			Возврат 0;
		КонецЕсли; 
	
		// выравнивание разрядности
		Число = Окр(Число, 27, ?(Число<0, РежимОкругления.Окр15как10, РежимОкругления.Окр15как20));
		
		// сумма с учетом погрешности предыдущих вычислений
		Округляемое = Число + Погрешность;

		// для отрицательного числа меняем направление округления, чтобы избежать ошибки Окр(-0.5) = -1
		Округленное	= Окр(Округляемое, Точность, ?(Округляемое<0, РежимОкругления.Окр15как10, РежимОкругления.Окр15как20));
		
		// рассчитаем новую погрешность округления
		Погрешность	= Округляемое - Округленное;
		
	КонецЕсли;
	
	Возврат Округленное;

КонецФункции // ОкруглитьСУчетомПогрешности()


//Преименование колонок таблицы значений по данным соответствия
Процедура ПереименованиеКолонок(ТаблицаЗначений, СоответствиеНазваний, Обратное = Ложь, СообщатьОбОшибке = Истина) Экспорт
	
	Колонки = ТаблицаЗначений.Колонки;
	
	Для каждого Колонка Из СоответствиеНазваний Цикл
		Если Обратное Тогда
			СтароеНазвание = Колонка.Значение;
			НовоеНазвание =  Колонка.Ключ;
		Иначе
			СтароеНазвание = Колонка.Ключ;
			НовоеНазвание =  Колонка.Значение;
		КонецЕсли;
		Если Колонки.Найти(СтароеНазвание) = неопределено тогда
			Если СообщатьОбОшибке Тогда
			    ОбщегоНазначения.СообщитьОбОшибке("При переименовании колонок таблиццы не обнаружена колонка с именем """+СтароеНазвание+"""! Переименование колонки не произведено.");
			КонецЕсли; 
		ИначеЕсли не Колонки.Найти(НовоеНазвание) = неопределено тогда
			Если СообщатьОбОшибке Тогда
			    ОбщегоНазначения.СообщитьОбОшибке("При переименовании колонок таблиццы обнаружена колонка с именем """+НовоеНазвание+""", переименование существующей колонки """+СтароеНазвание+""" невозможно! Переименование колонки не произведено.");
			КонецЕсли; 
		Иначе
			Колонки[СтароеНазвание].Имя = НовоеНазвание;
		КонецЕсли;
	КонецЦикла; 
	

КонецПроцедуры

//Удалает повторяющиеся элементы массива.
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 

	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМасссиве = Новый Соответствие; 
		БылоНеопределено = Ложь;
		
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента = ТипЗнч(ЭлементМассива); 
			Если ЭлементМассива = Неопределено Тогда
				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				Продолжить;
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) Тогда
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМасссиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМасссиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Функция производит поиск документа заданного вида, имеющего значение реквизита "ДокументОснование", равное
// переданной ссылке.
//
// Параметры:
//  ДокументСсылка  - ссылка на документ, для которого надо найти подчиненный документ,
//  ВидДокумента - строка, вид документа
//
// Возвращаемое значение:
//  Если нашли, то возвращаем ссылку, не нашли - Неопределено
//
Функция НайтиПодчиненныйДокумент(ДокументСсылка, ВидДокумента) Экспорт
	
	НайденныйДокумент = Неопределено;
	
	Если ЗначениеЗаполнено(ДокументСсылка) Тогда

		Запрос = Новый Запрос;

		// Установим параметры запроса
		Запрос.УстановитьПараметр("ДокументСсылка", ДокументСсылка);

		Запрос.Текст = 
		"ВЫБРАТЬ
		|	Ссылка 
		|ИЗ
		|	Документ." + ВидДокумента + "
		|
		|ГДЕ
		|	ДокументОснование = &ДокументСсылка";

		ВыборкаИзЗапроса = Запрос.Выполнить().Выбрать();

		Если ВыборкаИзЗапроса.Следующий() Тогда
			НайденныйДокумент = ВыборкаИзЗапроса.Ссылка;
		КонецЕсли;

	КонецЕсли;

	Возврат НайденныйДокумент;
	
КонецФункции // НайтиПодчиненныйДокумент()

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
	Возврат ИмяТабличнойЧасти;

КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

Функция ТоварЯвляетсяГорячимНапитком(КодТовара) Экспорт
	
	МассивНапитков = Новый Массив;
	МассивНапитков.Добавить("136760");
	МассивНапитков.Добавить("136753");
	МассивНапитков.Добавить("136761");
	МассивНапитков.Добавить("136759");
	МассивНапитков.Добавить("136763");
	МассивНапитков.Добавить("136765");
	МассивНапитков.Добавить("136764");
	МассивНапитков.Добавить("136767");
	МассивНапитков.Добавить("136771");
	
	Если МассивНапитков.Найти(КодТовара) <> Неопределено Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;	

КонецФункции	

// 05.05.2015 ++VS Скопировал процедру с обработки ОЗС_Работа_ФР. Не дорабатывал. Она сжимает наименование номенклатуры.
Функция УбратьИзСтрокиСлужебныеСимволы(Знач Стринг) Экспорт
	Перем Результат, Кратность;

	глДлиныПодстрок 												= Новый ТаблицаЗначений;
	глДлиныПодстрок.Колонки.Добавить("ИндексМассива");
	глДлиныПодстрок.Колонки.Добавить("ДлинаПодстроки");
	глДлиныПодстрок.Колонки.Добавить("ПрерватьЦикл");

	глСписокЦифр 													= Новый СписокЗначений;
	Для и1=1 По 10 Цикл 
		глСписокЦифр.Добавить(Сред("0123456789",и1,1));
	КонецЦикла;

	глРазрешенныеСимволы 											= Новый СписокЗначений;
	Для и1=1 По 72 Цикл 
		глРазрешенныеСимволы.Добавить(Сред("qwertyuiopasdfghjklzxcvbnmйцукенгшщзхъфывапролджэячсмитьбюєиії0123456789",и1,1));
	КонецЦикла;

	Стринг     	 													= СтрЗаменить(Стринг, "*", "");
    Стринг 															= СтрЗаменить(СтрЗаменить(Стринг, "і","i"), "І","I");
    	
	//фф070413 на пустых циклит
	Если ЗначениеЗаполнено(Стринг)=Ложь Тогда 
		Результат 													= ""; 
		Возврат Результат; 	
	КонецЕсли;
   	
    глДлиныПодстрок.Очистить();
	Результат          												= НРег(Стринг);
	Для ы = 1 По СтрДлина(Результат) Цикл
		ТекСимвол 													= Сред(Результат, ы, 1);
		Если глРазрешенныеСимволы.НайтиПоЗначению(ТекСимвол)=Неопределено Тогда
			Если ТекСимвол="," ИЛИ ТекСимвол="." Тогда
				Если НЕ глСписокЦифр.НайтиПоЗначению(Сред(Результат, ы-1, 1))=Неопределено И НЕ глСписокЦифр.НайтиПоЗначению(Сред(Результат, ы+1, 1))=Неопределено Тогда
					 Продолжить; // не убираем точки и запятые внутри цифр - нецелые объемы: 1.5л или 0,7л
				КонецЕсли;
			КонецЕсли;
			Результат 												= СтрЗаменить(Результат, Лев(Результат, ы), Лев(Результат, ы-1) + Символ(32));
		КонецЕсли;
	КонецЦикла;
	
	Результат 														= СокрЛП(ТРег(Результат));
	//Если НЕ Кратность = 0 Тогда
		
		ЭтоЦифра   													= Ложь;
		й          													= 0;
		ккк 														= СтрДлина(Результат)+5;  //+5 фф070413
		
		Пока й <= ккк Цикл
			й         												= й + 1;
			ТекСимвол 												= Сред(Результат, й, 1);
			
			Если НЕ глСписокЦифр.НайтиПоЗначению(ТекСимвол) = Неопределено Тогда
				Если НЕ ЭтоЦифра Тогда
					Результат 										= СтрЗаменить(Результат, Сред(Результат, й), Символ(32)+Сред(Результат, й)); // добавим пробелы перед первыми цифрами чисел
					ЭтоЦифра  										= Истина;
					й 												= й + 1;
				КонецЕсли;
			Иначе
				Если ЭтоЦифра Тогда             	
					Результат 										= СтрЗаменить(Результат, Лев(Результат, й-1), Лев(Результат, й-1) + Символ(32));
					ЭтоЦифра 										= Ложь;
					й 												= й + 1;
				КонецЕсли;
			КонецЕсли;
			
			Если СтрЧислоВхождений(Символ(32),Результат) > 32 Тогда
			     Прервать;
			КонецЕсли;
					
		КонецЦикла;

		// МАССИВ ПОДСТРОК                     	
		ПолучимСтроку  												= "";
		МассивПодстрок 												= ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(Результат, Символ(32));
		МаксИндекс     												= МассивПодстрок.ВГраница();
		МыВнутриЧисла  												= Ложь;
		ДесятичныйЗнак 												= ".";
		ДлинаВсехДо3хС 												= 0;
		ДлинаВсехПосле 												= 0;
		КоличВсехДо3хС 												= 0;
		КоличВсехПосле 												= 0;
		Для ы = 0 По МаксИндекс Цикл
			Подстрока      											= СокрЛП(МассивПодстрок[ы]);
			ДлинаПодстроки 											= СтрДлина(Подстрока);
			ДлинаВсехДо3хС 											= ДлинаВсехДо3хС + ?(ДлинаПодстроки<5, ДлинаПодстроки, 0);
			ДлинаВсехПосле 											= ДлинаВсехПосле + ?(ДлинаПодстроки>4, ДлинаПодстроки, 0);
			КоличВсехДо3хС 											= КоличВсехДо3хС + ?(ДлинаПодстроки<5, 1, 0);
			КоличВсехПосле 											= КоличВсехПосле + ?(ДлинаПодстроки>4, 1, 0);
			НоваяПодстрока 											= глДлиныПодстрок.Добавить();
			НоваяПодстрока.ИндексМассива  							= ы;
			НоваяПодстрока.ДлинаПодстроки 							= ДлинаПодстроки;
			НоваяПодстрока.ПрерватьЦикл   							= 0;
		КонецЦикла;
		
		СвободноСимволов 											= 48 - ДлинаВсехДо3хС;
		
		глДлиныПодстрок.Сортировать("ДлинаПодстроки Убыв");
		
		ЛишнихСимволов 												= ДлинаВсехПосле;
		ВыйтиИзЦиклаПока 											= Ложь;
		Пока ЛишнихСимволов > СвободноСимволов Цикл
			Если ВыйтиИзЦиклаПока Тогда
				Прервать;
			КонецЕсли;
			Для каждого Подстрока Из глДлиныПодстрок Цикл
				Если ЛишнихСимволов <= СвободноСимволов Тогда
					ВыйтиИзЦиклаПока 								= Истина;
					Прервать;
				КонецЕсли;
				Если Число(Подстрока.ДлинаПодстроки)<5 Тогда
					Подстрока.ПрерватьЦикл 							= 1;
					Если глДлиныПодстрок.Количество()=глДлиныПодстрок.Итог("ПрерватьЦикл") Тогда
						ВыйтиИзЦиклаПока 							= Истина;
						Прервать;
					КонецЕсли;
					Продолжить;
				КонецЕсли;
				Если НЕ глСписокЦифр.НайтиПоЗначению(Лев(МассивПодстрок[Число(Подстрока.ИндексМассива)],1)) = Неопределено Тогда
					Подстрока.ПрерватьЦикл 							= 1;
					Если глДлиныПодстрок.Количество()=глДлиныПодстрок.Итог("ПрерватьЦикл") Тогда
						ВыйтиИзЦиклаПока 							= Истина;
						Прервать;
					КонецЕсли;
					Продолжить;
				КонецЕсли;
				МассивПодстрок[Число(Подстрока.ИндексМассива)] 		= Лев(МассивПодстрок[Число(Подстрока.ИндексМассива)], Число(Подстрока.ДлинаПодстроки)-1);
				Подстрока.ДлинаПодстроки 							= СтрДлина(МассивПодстрок[Число(Подстрока.ИндексМассива)]);
				ЛишнихСимволов 										= ЛишнихСимволов - 1;	
			КонецЦикла;
		КонецЦикла;
		
		Для ы = 0 По МаксИндекс Цикл
			Подстрока      											= СокрЛП(МассивПодстрок[ы]);
			
			Если глСписокЦифр.НайтиПоЗначению(Сред(Подстрока, 1, 1))=Неопределено Тогда
				ПолучимСтроку 										= ПолучимСтроку + Подстрока;
				Если МыВнутриЧисла=Истина Тогда
					МыВнутриЧисла 									= Ложь;
				КонецЕсли;
			Иначе
				Если МыВнутриЧисла Тогда
					ПолучимСтроку 									= ПолучимСтроку +  ДесятичныйЗнак + Подстрока;
					МыВнутриЧисла 									= Ложь;
				Иначе
					ПолучимСтроку 									= ПолучимСтроку + Подстрока;
					МыВнутриЧисла 									= Истина;
				КонецЕсли;	
			КонецЕсли;
		КонецЦикла;
		Результат 													= ПолучимСтроку;
		
	//КонецЕсли;
	
	Результат 														= СокрЛП(СтрЗаменить(Результат, Символ(32), ""));
	ДлинаРезультата 												= СтрДлина(Результат);
	Если ДлинаРезультата > 48 Тогда  //И Прав(Результат, 1) = "л"
		
		ПредпоследняяПодстрока 										= СокрЛП(МассивПодстрок[МаксИндекс-1]);
		Для Счетчик=1 По СтрДлина(ПредпоследняяПодстрока) Цикл
			ТекущийСимвол 											= Сред(ПредпоследняяПодстрока, Счетчик, 1);
			Если НЕ глСписокЦифр.НайтиПоЗначению(ТекущийСимвол)=Неопределено Тогда
				ОкончаниеСтрокиРезультата 							= ПредпоследняяПодстрока + СокрЛП(МассивПодстрок[МаксИндекс]);
				ДлинаОкончанияРезультата  							= СтрДлина(ОкончаниеСтрокиРезультата);
				ДлинаНачалаРезультата     							= 48 - ДлинаОкончанияРезультата;
				Результат                 							= Лев(Результат, ДлинаНачалаРезультата)+ОкончаниеСтрокиРезультата;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Результат 													= Лев(Результат, 48);
	КонецЕсли;
		
	Возврат Результат;
КонецФункции

Функция УбратьИзКодаВедущиеНули(ВыбКод) Экспорт
	Пока Лев(ВыбКод, 1) = "0" Цикл
		ВыбКод = Сред(ВыбКод, 2);
	КонецЦикла;
	ВыбКод = СтрЗаменить(ВыбКод, Символы.НПП, "");
	Возврат ВыбКод;
КонецФункции

Функция ДополнитьКодНулями(ВыбКод) Экспорт
	Возврат Прав("000000"+ВыбКод,6)	
КонецФункции

//Мулько 14.11.2019
Функция ОтправитьПоПочте(ИмяФайлаВложение, Адрес, Тема, ТекстПисьма) Экспорт
	
    АдресСервераSMTP = "mail.prostor.ua";
    ПользовательSMTP = "1Czvit";
    ПарольSMTP = "3mNsB31r";
    Отправитель = "1Czvit@prostor.ua";
    
    ПараметрыПочты = Новый ИнтернетПочтовыйПрофиль;
    ПараметрыПочты.АдресСервераSMTP 	= АдресСервераSMTP;
    ПараметрыПочты.АутентификацияSMTP 	= СпособSMTPАутентификации.ПоУмолчанию;
    ПараметрыПочты.ПользовательSMTP 	= ПользовательSMTP;
    ПараметрыПочты.ПарольSMTP 			= ПарольSMTP;
	ПараметрыПочты.ПортSMTP				= 587;
     
    Письмо = Новый ИнтернетПочтовоеСообщение;
	Письмо.Тема = Тема;
	Письмо.ИмяОтправителя = "1С отправка отчетов";
    Письмо.Отправитель = Отправитель;
	Письмо.Получатели.Добавить(Адрес);    
	//Письмо.Получатели.Добавить("konstantin.mulko@prostor.ua");
	//Письмо.Получатели.Добавить("artem.dyachenko@prostor.ua"); 
	
	Письмо.Тексты.Добавить(ТекстПисьма);        
	Если ИмяФайлаВложение <> Неопределено Тогда
    	Письмо.Вложения.Добавить(ИмяФайлаВложение);
	КонецЕсли;	
     
    Подключение = Новый ИнтернетПочта;
	
	Попытка
		
        Подключение.Подключиться(ПараметрыПочты);
        Подключение.Послать(Письмо);
		Логирование.ДобавитьЗаписьЖурнала(,"ОтправитьПоПочте", "Письмо успешно отправлено", Неопределено, Неопределено, "ОбщийМодуль.РабочееМестоКассира");
		
		Возврат Истина;
		
	Исключение
		
		Логирование.ДобавитьЗаписьЖурнала(УровеньЖурналаРегистрации.Ошибка, "ОтправитьПоПочте", ОписаниеОшибки(), Неопределено, Неопределено, "ОбщийМодуль.ОбщегоНазначения");
    	Сообщить("Ошибка при отправке почты! " + ОписаниеОшибки());
		
		Возврат Ложь;
		
    КонецПопытки;
	
КонецФункции

Функция ПолучитьПеречислениеПоСинониму(ИмяПеречисления, Синоним) Экспорт
	
	Для Каждого ЭлементПеречисления Из Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления Цикл
		Если СокрЛП(ЭлементПеречисления) = Синоним Тогда
			Возврат Вычислить("Перечисления." + ИмяПеречисления + "." + ЭлементПеречисления.Имя);
		КонецЕсли;
	КонецЦикла;	
	
КонецФункции	

//Мулько 27.12.2019
Функция ЭтоПодарочныйСертификат(Код) Экспорт
	
	КодПС = Код;
	
	МассивПС = Новый Массив();
	МассивПС.Добавить("86788");
	МассивПС.Добавить("86789");
	МассивПС.Добавить("86790");
	МассивПС.Добавить("86917");//500 грн
	МассивПС.Добавить("136249");
	МассивПС.Добавить("136250");
	//Мулько 05.03.2020
	//Добавил УбратьИзКодаВедущиеНули
	Если МассивПС.Найти(ОбщегоНазначения.УбратьИзКодаВедущиеНули(КодПС)) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;	
	
КонецФункции	

Функция ПолучитьКодСертификатаПоШтрихкоду(ШК, Объект) Экспорт
	
	 //Если ПС уже задействован в чеке, тогда мы эго не берем во внимание.
    МвссивПС = Объект.ТЧ_ДвиженияПС.НайтиСтроки(Новый Структура("ШК_ПС", ШК));
	Если МвссивПС.Количество() > 0 Тогда           	    	
		Возврат МвссивПС[0];	    
	КонецЕсли;	
 		
КонецФункции	
	
#Область BAS_Розница_вспомогательные

Функция ПолучитьПрокси(WSАдрес,WSПользователь,WSПароль,URI,ИмяСервиса,Таймаут = 180) Экспорт
	Прокси = Неопределено;
	ИнтернетПрокси = Новый ИнтернетПрокси(ЛОЖЬ);
	ТаймаутКонстанта = Константы.Розница_ТаймаутЗапросов.Получить();
	Если ТаймаутКонстанта > 0 Тогда
		Таймаут = ТаймаутКонстанта;
	КонецЕсли;
	Попытка					
		Определение = Новый WSОпределения(WSАдрес,WSПользователь,WSПароль,ИнтернетПрокси,Таймаут);				
		Прокси 		= Новый WSПрокси(Определение,URI,ИмяСервиса,ИмяСервиса + "Soap",ИнтернетПрокси,Таймаут);				
		Прокси.Пользователь	= WSПользователь;
		Прокси.Пароль		= WSПароль;
	Исключение
		ЗаписьЖурналаРегистрации("Недоступен сервер " + WSАдрес,УровеньЖурналаРегистрации.Ошибка,,"Прокси","ОШИБКА: " + ОписаниеОшибки());
	КонецПопытки;
	Возврат Прокси;

КонецФункции

#КонецОбласти

#Область Выгрузка_WebСервис

Функция ПолучитьШапкаЧекаККМ_ОтправитьНаСервер(Ссылка) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ЧекККМ.Ссылка КАК Ссылка,
	               |	ЧекККМ.Номер,
	               |	ЧекККМ.Дата КАК Дата,
	               |	ЧекККМ.BPMonline_PreprocessingId,
	               |	ЧекККМ.BPMonline_ДатаЗакрытия,
	               |	ЧекККМ.BPMonline_ИмяВладельца,
	               |	ПРЕДСТАВЛЕНИЕ(ЧекККМ.BPMonline_СостояниеЧекаККМ) КАК BPMonline_СостояниеЧекаККМ,
	               |	ЧекККМ.BPMonline_СтатусКарты,
	               |	ЧекККМ.BPMonline_ТипКарты,
	               |	ЧекККМ.BPMonline_ШК,
	               |	ЧекККМ.FISHKA_originalTrnNoPOSFZS,
	               |	ЧекККМ.FISHKA_trnNoPOSFZS,
	               |	ПРЕДСТАВЛЕНИЕ(ЧекККМ.FISHKA_СостояниеЧекаККМ) КАК FISHKA_СостояниеЧекаККМ,
	               |	ЧекККМ.FISHKA_ШК,
	               |	ЧекККМ.POSтерминал_RRN,
	               |	ЧекККМ.POSтерминал_ВладелецКарты,
	               |	ЧекККМ.POSтерминал_КодАвторизации,
	               |	ЧекККМ.POSтерминал_НомерКарты,
	               |	ЧекККМ.POSтерминал_НомерЧека,
	               |	ЧекККМ.POSтерминал_ТранзакцияВыполнена,
	               |	ПРЕДСТАВЛЕНИЕ(ЧекККМ.ВидОперацииЧекаККМ) КАК ВидОперацииЧекаККМ,
	               |	ЧекККМ.Возврат_RRN,
	               |	ЧекККМ.Возврат_ДатаОперации,
	               |	ЧекККМ.Возврат_КодТТ,
	               |	ЧекККМ.Возврат_НомерЧекаККМ,
	               |	ЧекККМ.Возврат_СерийныйНомерФР,
	               |	ЧекККМ.Возврат_ШК_БК,
	               |	ПРЕДСТАВЛЕНИЕ(ЧекККМ.КассаККМ) КАК КассаККМ,
	               |	ЧекККМ.Кассир,
	               |	ЧекККМ.НомерZОтчета,
	               |	ЧекККМ.НомерЧекаККМ,
	               |	ЧекККМ.НомерЧекаККМ_ТекущейСмены,
	               |	ЧекККМ.Общ_Промокод,
	               |	ПРЕДСТАВЛЕНИЕ(ЧекККМ.Подразделение) КАК Подразделение,
	               |	ПРЕДСТАВЛЕНИЕ(ЧекККМ.СостояниеЧекаККМ) КАК СостояниеЧекаККМ,
	               |	ЧекККМ.СуммаОплаты_БезНал,
	               |	ЧекККМ.СуммаОплаты_Ваучер,
	               |	ЧекККМ.СуммаОплаты_Нал,
	               |	ЧекККМ.СуммаОплаты_ПС,
	               |	ЧекККМ.СуммаПоЧекуККМ,
	               |	ПРЕДСТАВЛЕНИЕ(ЧекККМ.АкционнаяСистема) КАК АкционнаяСистема,
	               |	ЧекККМ.UUID_ЧекаККМ_ИзРозница,
	               |	ЧекККМ.КассаККМ.Код,
	               |	ЧекККМ.Подразделение.Код
	               |ИЗ
	               |	Документ.ЧекККМ КАК ЧекККМ
	               |ГДЕ
	               |	ЧекККМ.Ссылка = &Ссылка
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	Дата,
	               |	Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	РезультатЗапроса = Запрос.Выполнить();
	Таблица = РезультатЗапроса.Выгрузить();
	
	Возврат  Таблица;
	
КонецФункции

Функция ПолучитьТЧ_ТоварыЧекаККМ_ОтправитьНаСервер(Ссылка) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ЧекККМТовары.НомерСтроки,
	               |	ПРЕДСТАВЛЕНИЕ(ЧекККМТовары.ВидОперации) КАК ВидОперации,
	               |	ЧекККМТовары.Код КАК НоменклатураКод,
	               |	ЧекККМТовары.Наименование,
	               |	ЧекККМТовары.Количество,
	               |	ЧекККМТовары.Цена,
	               |	ПРЕДСТАВЛЕНИЕ(ЧекККМТовары.СтавкаНДС) КАК СтавкаНДС,
	               |	ЧекККМТовары.Сумма,
	               |	ЧекККМТовары.СкидкаСумма,
	               |	ЧекККМТовары.СкидкаБК,
	               |	ЧекККМТовары.Ответственный,
	               |	ЧекККМТовары.Возврат_НомерСтроки,
	               |	ЧекККМТовары.Акционный
	               |ИЗ
	               |	Документ.ЧекККМ.ТЧ_Товары КАК ЧекККМТовары
	               |ГДЕ
	               |	ЧекККМТовары.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	РезультатЗапроса = Запрос.Выполнить();
	Таблица = РезультатЗапроса.Выгрузить();
	
	Возврат  Таблица;
	
КонецФункции

Функция ПолучитьТЧ_ЖурналСкидокЧекаККМ_ОтправитьНаСервер(Ссылка) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ЧекККМЖурналСкидок.НомерСтроки,
	               |	ЧекККМЖурналСкидок.Код КАК НоменклатураКод,
	               |	ЧекККМЖурналСкидок.Количество,
	               |	ЧекККМЖурналСкидок.Цена,
	               |	ЧекККМЖурналСкидок.СкидкаСумма,
	               |	ЧекККМЖурналСкидок.ТипАкции,
	               |	ЧекККМЖурналСкидок.НомерАкции,
	               |	ЧекККМЖурналСкидок.ТоварГрВыдачи,
	               |	ЧекККМЖурналСкидок.БлокЛистовок_Код,
	               |	ЧекККМЖурналСкидок.БлокЛистовок_UUID_ИзУТ,
	               |	ЧекККМЖурналСкидок.НомСтрокиЧекаККМ,
	               |	ЧекККМЖурналСкидок.ШК_Акции,
	               |	ЧекККМЖурналСкидок.ID_акции,
	               |	ПРЕДСТАВЛЕНИЕ(ЧекККМЖурналСкидок.АкционнаяСистема) КАК АкционнаяСистема
	               |ИЗ
	               |	Документ.ЧекККМ.ТЧ_ЖурналСкидок КАК ЧекККМЖурналСкидок
	               |ГДЕ
	               |	ЧекККМЖурналСкидок.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	РезультатЗапроса = Запрос.Выполнить();
	Таблица = РезультатЗапроса.Выгрузить();
	
	Возврат Таблица;
	
КонецФункции	

Функция ПолучитьТЧ_ДвиженияПСЧекаККМ_ОтправитьНаСервер(Ссылка) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ПРЕДСТАВЛЕНИЕ(ТЧ_ДвиженияПС.СтатусПС) КАК СтатусПС,
	               |	ТЧ_ДвиженияПС.ШК_ПС КАК ШК_ПС,
	               |	ТЧ_ДвиженияПС.НоминалПС,
	               |	ТЧ_ДвиженияПС.ЭлектронныйПС
	               |ИЗ
	               |	Документ.ЧекККМ.ТЧ_ДвиженияПС КАК ТЧ_ДвиженияПС
	               |ГДЕ
	               |	ТЧ_ДвиженияПС.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	РезультатЗапроса = Запрос.Выполнить();
	Таблица = РезультатЗапроса.Выгрузить();
	
	Возврат  Таблица;
	
КонецФункции	

Функция ПолучитьТЧ_СобытияПоЧекуЧекаККМ_ОтправитьНаСервер(Ссылка) Экспорт
		//{{КОНСТРУКТОР_ЗАПРОСА_С_ОБРАБОТКОЙ_РЕЗУЛЬТАТА
	// Данный фрагмент построен конструктором.
	// При повторном использовании конструктора, внесенные вручную изменения будут утеряны!!!
	
	Запрос 																	= Новый Запрос;
	Запрос.Текст 															= "ВЫБРАТЬ
	             															  |	ЧекККМТЧ_СобытияПоЧеку.ДатаСобытия,
	             															  |	ЧекККМТЧ_СобытияПоЧеку.ВидСобытия
	             															  |ИЗ
	             															  |	Документ.ЧекККМ.ТЧ_СобытияПоЧеку КАК ЧекККМТЧ_СобытияПоЧеку
	             															  |ГДЕ
	             															  |	ЧекККМТЧ_СобытияПоЧеку.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", 		Ссылка);
	РезультатЗапроса 														= Запрос.Выполнить();
	Таблица																	= РезультатЗапроса.Выгрузить();
	
	Возврат  Таблица
КонецФункции	

#КонецОбласти